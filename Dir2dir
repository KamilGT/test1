#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *buf, path[100], *dir = "C:\\Users\\User\\Documents\\test_dir\\";
    size_t len, siz;
    FILE *fin, *fout;
    
    strcpy(path, dir);
    strcat(path, "x.txt");
    //printf("%s \n", path);
    fin = fopen(path,"rb"); //открывает файл input.txt на чтение и возвращает его указатель.
    if (fin  == NULL ) //проверка указателя файла на NULL и вывод ошибки
    {
        printf("Can't open file <x.txt>\n");
        exit(1);
    }

    fseek(fin, 0, SEEK_END); //устанавливает позицию в потоке данных fin.
    //Относительно установленной позиции будет осуществляться чтение и запись данных.
    len = ftell(fin); //определяет текущую позицию в потоке данных fin
    rewind(fin); /*устанавливает текущую позицию для чтения/записи файла, связанного с потоком данных fin, 
    в начало файла и сбрасывает индикатор ошибок потока данных.*/
    //printf("%d \n", len);

    buf = (char*)malloc(len + 1); //Функция выделяет len байтов памяти и возвращает указатель на неё и присваивает в buf 
    if ( buf == NULL ) //проверка buf, если память выделить не удалось, то функция возвращает NULL и вывод ошибки
    {
        printf("Memory error!\n");
        exit(2);
    }
    buf[len] = '\0'; 
    siz = fread(buf, 1, len, fin); /*считывает len объектов — каждый объект по 1 символу в длину — из потока fin
    и помещает их в символьный массив, указанный в buf. Указатель пози­ции в файле продвигается вперед 
    на количество считанных символов. Функция fread() возвращает количество действительно считанных объектов.*/
    //printf("%s \n", buf);
    if (siz != len ) 
    {
        printf("Can't read input file!\n");
        exit(3);
    }
    fclose(fin); /*используется для закрытия потока, ранее открытого с помощью fopen() input.txt. 
    Cохраняет в файл данные, находящиеся в дисковом буфере, 
    и выполняет операцию системного уровня по закрытию файла.*/
    
    strcpy(path, dir);
    strcat(path, "Catalog\\y.txt");
    
    fout = fopen(path, "w"); //открывает файл output.txt на запись и возвращает его указатель.
    if ( fout == NULL ) //проверка указателя файла на NULL и вывод ошибки
    {
        printf("Can't open file <output.txt> for output!\n");
        exit(4);
    }
    
    siz = fwrite(buf, 1, len, fout); /*записывает len единиц данных (размер каждого 1 байт) в поток, 
    на который указывает fout, получая их из расположения, на которое указывает str. Возвращает количество 
    записанных элементов.*/
    if (siz != len )  //В случае ошибки возвращаемый результат не будет равен значению len.
    {
        printf("Can't write to output file!\n");
        exit(1);
    }
    fclose(fout); //используется для закрытия потока, ранее открытого с помощью fopen() output.txt.
    
    free(buf); //Освобождает ранее выделенный блок памяти, на начало которого указывает указатель buf
    exit(0);
}
